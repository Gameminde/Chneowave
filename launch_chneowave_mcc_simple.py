#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de lancement simplifi√© de CHNeoWave avec backend MCC
"""

import os
import sys
import logging
import time
import numpy as np
from threading import Thread, Event
from typing import Optional, List, Dict, Any, Callable
from ctypes import *
from ctypes.wintypes import *

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

# Constantes pour les DLLs MCC
MCC_DLL_PATH = os.path.join("Measurement Computing", "DAQami")

class MCCBackend:
    """Backend pour cartes d'acquisition Measurement Computing"""
    
    SUPPORTED_SAMPLE_RATES = [32, 100, 500, 1000]
    MAX_CHANNELS = 16
    
    def __init__(self, config: dict):
        self.config = config
        self.is_running = False
        self.acquisition_thread: Optional[Thread] = None
        self.stop_event = Event()
        self.data_callback: Optional[Callable[[np.ndarray], None]] = None
        self.error_callback: Optional[Callable[[str], None]] = None
        
        # Configuration par d√©faut
        self.sample_rate = self.config.get('sample_rate', 32)
        self.num_channels = self.config.get('channels', 8)
        self.device_id = self.config.get('device_id', 0)
        self.voltage_range = self.config.get('voltage_range', (-10.0, 10.0))
        
        # Handles pour les DLLs
        self.hal_dll = None
        self.ul_dll = None
        self.device_handle = None
        
        # √âtat de l'acquisition
        self.buffer_size = 1024
        self.data_buffer = None
        
        logger.info("Backend MCC initialis√©")
        self._load_dlls()
    
    def _load_dlls(self):
        """Charge les DLLs Measurement Computing"""
        try:
            # Charger HAL.dll
            hal_path = os.path.join(MCC_DLL_PATH, "HAL.dll")
            if os.path.exists(hal_path):
                self.hal_dll = CDLL(hal_path)
                logger.info(f"DLL HAL charg√©e: {hal_path}")
            else:
                logger.warning(f"DLL HAL non trouv√©e: {hal_path}")
            
            # Charger ULx.dll
            ul_path = os.path.join(MCC_DLL_PATH, "ULx.dll")
            if os.path.exists(ul_path):
                self.ul_dll = CDLL(ul_path)
                logger.info(f"DLL ULx charg√©e: {ul_path}")
            else:
                logger.warning(f"DLL ULx non trouv√©e: {ul_path}")
                
        except Exception as e:
            logger.error(f"Erreur lors du chargement des DLLs MCC: {e}")
    
    @classmethod
    def is_available(cls) -> bool:
        """V√©rifie si les DLLs MCC sont disponibles"""
        hal_path = os.path.join(MCC_DLL_PATH, "HAL.dll")
        ul_path = os.path.join(MCC_DLL_PATH, "ULx.dll")
        return os.path.exists(hal_path) and os.path.exists(ul_path)
    
    @classmethod
    def detect_devices(cls) -> List[Dict[str, Any]]:
        """D√©tecte les cartes MCC disponibles"""
        devices = []
        try:
            # Simulation de d√©tection - √† adapter selon les vraies fonctions DLL
            devices = [
                {"id": 0, "name": "USB-1608G", "type": "USB", "channels": 8},
                {"id": 1, "name": "USB-1208HS", "type": "USB", "channels": 8},
            ]
            logger.info(f"Cartes MCC d√©tect√©es: {len(devices)}")
        except Exception as e:
            logger.error(f"Erreur lors de la d√©tection des cartes MCC: {e}")
        
        return devices
    
    def open(self) -> bool:
        """Ouvre la connexion avec la carte MCC"""
        try:
            if not self.hal_dll:
                logger.error("DLL HAL non charg√©e")
                return False
            
            # Simulation d'ouverture de connexion
            self.device_handle = 1  # Handle simul√©
            logger.info(f"Connexion MCC ouverte, handle: {self.device_handle}")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors de l'ouverture de la connexion MCC: {e}")
            return False
    
    def close(self):
        """Ferme la connexion avec la carte MCC"""
        try:
            if self.device_handle:
                # Simulation de fermeture
                self.device_handle = None
                logger.info("Connexion MCC ferm√©e")
        except Exception as e:
            logger.error(f"Erreur lors de la fermeture de la connexion MCC: {e}")
    
    def configure_acquisition(self, sample_rate: int, num_samples_per_channel: int):
        """Configure les param√®tres d'acquisition"""
        try:
            self.sample_rate = sample_rate
            self.buffer_size = num_samples_per_channel
            
            # Allouer le buffer de donn√©es
            self.data_buffer = np.zeros((self.num_channels, self.buffer_size))
            
            logger.info(f"Acquisition MCC configur√©e: Fs={sample_rate}Hz, N={num_samples_per_channel}")
            
        except Exception as e:
            logger.error(f"Erreur lors de la configuration de l'acquisition MCC: {e}")
    
    def configure_channels(self, channels: list):
        """Configure les canaux √† acqu√©rir"""
        try:
            self.num_channels = len(channels)
            logger.info(f"{self.num_channels} canaux MCC configur√©s")
            
        except Exception as e:
            logger.error(f"Erreur lors de la configuration des canaux MCC: {e}")
    
    def start(self):
        """D√©marre l'acquisition des donn√©es"""
        if self.is_running:
            logger.warning("L'acquisition MCC est d√©j√† en cours")
            return
        
        try:
            self.is_running = True
            self.stop_event.clear()
            self.acquisition_thread = Thread(target=self._acquisition_loop)
            self.acquisition_thread.start()
            logger.info("Acquisition MCC d√©marr√©e")
            
        except Exception as e:
            logger.error(f"Erreur lors du d√©marrage de l'acquisition MCC: {e}")
            self.is_running = False
    
    def stop(self):
        """Arr√™te l'acquisition des donn√©es"""
        if not self.is_running:
            logger.warning("L'acquisition MCC n'est pas en cours")
            return
        
        try:
            self.stop_event.set()
            if self.acquisition_thread:
                self.acquisition_thread.join()
            self.is_running = False
            logger.info("Acquisition MCC arr√™t√©e")
            
        except Exception as e:
            logger.error(f"Erreur lors de l'arr√™t de l'acquisition MCC: {e}")
    
    def read(self) -> np.ndarray:
        """Lit les donn√©es acquises depuis la carte MCC"""
        try:
            if self.data_buffer is not None:
                return self.data_buffer.copy()
            else:
                return np.array([])
                
        except Exception as e:
            logger.error(f"Erreur lors de la lecture des donn√©es MCC: {e}")
            return np.array([])
    
    def get_status(self) -> dict:
        """Retourne l'√©tat actuel de la carte MCC"""
        return {
            'running': self.is_running,
            'device_handle': self.device_handle,
            'sample_rate': self.sample_rate,
            'channels': self.num_channels,
            'buffer_size': self.buffer_size
        }
    
    def _acquisition_loop(self):
        """Boucle d'acquisition en arri√®re-plan"""
        while not self.stop_event.is_set():
            try:
                # G√©n√©rer des donn√©es simul√©es pour le test
                data = self._generate_mcc_data()
                
                if self.data_buffer is not None:
                    self.data_buffer = data
                
                if self.data_callback:
                    self.data_callback(data)
                
                # Attendre selon la fr√©quence d'√©chantillonnage
                time.sleep(self.buffer_size / self.sample_rate)
                
            except Exception as e:
                logger.error(f"Erreur dans la boucle d'acquisition MCC: {e}")
                if self.error_callback:
                    self.error_callback(str(e))
                break
    
    def _generate_mcc_data(self) -> np.ndarray:
        """G√©n√®re des donn√©es simul√©es pour les tests"""
        t = np.linspace(0, self.buffer_size / self.sample_rate, self.buffer_size, endpoint=False)
        data = np.zeros((self.num_channels, self.buffer_size))
        
        for i in range(self.num_channels):
            # Signal sinuso√Ødal avec bruit pour simuler des donn√©es r√©elles
            freq = 1.0 + i * 0.5  # Fr√©quence diff√©rente pour chaque canal
            phase = np.pi / 4 * i
            signal = np.sin(2 * np.pi * freq * t + phase)
            noise = np.random.normal(0, 0.1, self.buffer_size)
            data[i, :] = signal + noise
        
        return data

class CHNeoWaveMCC:
    """Interface simplifi√©e de CHNeoWave avec backend MCC"""
    
    def __init__(self):
        self.backend = None
        self.is_running = False
        
    def initialize(self):
        """Initialise CHNeoWave avec le backend MCC"""
        print("üåä Initialisation de CHNeoWave avec backend MCC...")
        
        # V√©rifier la disponibilit√© du backend MCC
        if not MCCBackend.is_available():
            print("‚ùå Backend MCC non disponible")
            return False
        
        # D√©tecter les cartes
        devices = MCCBackend.detect_devices()
        if not devices:
            print("‚ùå Aucune carte MCC d√©tect√©e")
            return False
        
        print(f"‚úÖ {len(devices)} carte(s) MCC d√©tect√©e(s)")
        for device in devices:
            print(f"   - {device['name']} (ID: {device['id']})")
        
        # Configuration du backend
        config = {
            'sample_rate': 32,
            'channels': 8,
            'device_id': 0,
            'voltage_range': (-10.0, 10.0)
        }
        
        try:
            self.backend = MCCBackend(config)
            print("‚úÖ Backend MCC initialis√©")
            return True
        except Exception as e:
            print(f"‚ùå Erreur lors de l'initialisation: {e}")
            return False
    
    def start_acquisition(self):
        """D√©marre l'acquisition de donn√©es"""
        if not self.backend:
            print("‚ùå Backend non initialis√©")
            return False
        
        try:
            # Ouvrir la connexion
            if not self.backend.open():
                print("‚ùå √âchec de l'ouverture de connexion")
                return False
            
            # Configuration
            self.backend.configure_acquisition(32, 1024)
            self.backend.configure_channels([{'id': i} for i in range(8)])
            
            # Callback pour les donn√©es
            def data_callback(data):
                print(f"üìä Donn√©es acquises: {data.shape}, Min: {data.min():.3f}, Max: {data.max():.3f}")
            
            self.backend.data_callback = data_callback
            
            # D√©marrer l'acquisition
            self.backend.start()
            self.is_running = True
            
            print("‚úÖ Acquisition d√©marr√©e")
            return True
            
        except Exception as e:
            print(f"‚ùå Erreur lors du d√©marrage: {e}")
            return False
    
    def stop_acquisition(self):
        """Arr√™te l'acquisition de donn√©es"""
        if self.backend and self.is_running:
            self.backend.stop()
            self.backend.close()
            self.is_running = False
            print("‚úÖ Acquisition arr√™t√©e")
    
    def get_status(self):
        """Retourne le statut du syst√®me"""
        if self.backend:
            return self.backend.get_status()
        return {'status': 'non_initialis√©'}

def main():
    """Fonction principale"""
    print("=" * 70)
    print("üåä CHNeoWave - Lancement avec Backend MCC")
    print("=" * 70)
    
    # Cr√©er l'instance de CHNeoWave
    chneowave = CHNeoWaveMCC()
    
    # Initialiser
    if not chneowave.initialize():
        print("‚ùå √âchec de l'initialisation")
        return
    
    print("\nüéØ CHNeoWave est pr√™t avec le backend MCC!")
    print("üìã Fonctionnalit√©s disponibles:")
    print("   - Acquisition temps r√©el")
    print("   - Support cartes Measurement Computing")
    print("   - Configuration multi-canaux")
    print("   - Gestion des donn√©es simul√©es")
    
    # D√©marrer l'acquisition
    print("\nüöÄ D√©marrage de l'acquisition...")
    if chneowave.start_acquisition():
        print("‚úÖ Acquisition en cours...")
        print("‚è≥ Appuyez sur Ctrl+C pour arr√™ter")
        
        try:
            # Maintenir l'acquisition active
            while True:
                time.sleep(1)
                status = chneowave.get_status()
                if status.get('running'):
                    print(f"üìä Statut: En cours - Fs: {status.get('sample_rate')}Hz, Canaux: {status.get('channels')}")
                else:
                    break
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Arr√™t demand√© par l'utilisateur")
        finally:
            chneowave.stop_acquisition()
    
    print("\n" + "=" * 70)
    print("‚úÖ CHNeoWave avec backend MCC - Test termin√©")
    print("=" * 70)

if __name__ == "__main__":
    main()
