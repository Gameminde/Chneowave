# mcp_jobs/final_hardening.yml
# OBJECTIF : verrouiller la distribution OFFLINE, exposer les CLI,
# intégrer la carte IOTech, augmenter la couverture tests ≥ 90 %,
# garantir les performances et la conformité laboratoire.

mode: repair
ignore_paths:
  - "venv*/"
  - "__pycache__/"
  - "logs/**"
  - "exports/**"

env:
  CHNW_MODE: "offline"          # AUCUN accès réseau autorisé
  CHNW_FS: "500"
  CHNW_N_PROBES: "16"
  CHNW_GEOM: "config/probes_geom.json"

tasks:

# 1. Purge TOTALE des appels réseau
- name: purge_network_access
  description: >
    Dans tous les scripts __fixes__/, wrappez les imports ou usages de
    `requests`, `urllib`, `socket.create_connection`, `ftplib`, `paramiko`
    derrière :
        if os.getenv("CHNW_MODE", "offline") != "offline":
            ...
    Toute tentative réseau en mode offline doit lever
        RuntimeError("Network disabled in offline mode").
    Ajouter un test pytest `tests/test_offline_guard.py` qui monkey-patch
    create_connection et vérifie l'exception.
  produce_patch: "__fixes__/patch_purge_network.patch"

# 2. Enregistrement réel des CLI
- name: register_cli
  description: >
    Déplace complete_guide.py, lab_configurator.py, quick_start_guide.py,
    final_validation.py, automated_deployment.py, update_manager.py dans
        src/hrneowave/tools/
    Met à jour pyproject.toml :
        [project.scripts]
        hr-complete-guide = "hrneowave.tools.complete_guide:main"
        hr-lab-config     = "hrneowave.tools.lab_configurator:main"
        hr-final-validate = "hrneowave.tools.final_validation:main"
        hr-update-manager = "hrneowave.tools.update_manager:main"
    Crée tests CLI `tests/test_cli_help.py` (exec --help → exit 0).
  produce_patch: "__fixes__/patch_register_cli.patch"

# 3. Backend carte IOTech Personal Daq 3000
- name: hw_iotech_backend
  description: >
    Implémente src/hrneowave/hw/iotech_backend.py :
      • classe IOTechSession(DAQSession) utilisant ctypes pour daqx.dll
      • sélection via env CHNW_IO_DEVICE (ex "DaqBoard3K0")
      • méthodes : open(), start(FS), read(n_samples) -> np.ndarray,
        stop(), close()
      • support SE/diff et ±10 V…±100 mV
    Ajoute test mock `tests/test_iotech_backend.py` (pytest, monkey-patch
    ctypes.WinDLL) vérifiant open/start/read/stop.
  produce_patch: "__fixes__/patch_hw_iotech_backend.patch"

# 4. Tests ring-buffer & acquisition asynchrone
- name: tests_buffer_async
  description: >
    Crée tests/test_buffer_async.py :
      • pousse 10^7 échantillons multithread,
        vérifie aucune perte (len == produced)
      • test overflow → dernière valeur correcte
    Crée tests/test_async_acq_sim.py : simulate producer/consumer à 500 Hz
      sur 16 canaux pendant 30 s → latence max < 50 ms.
  produce_patch: "__fixes__/patch_tests_buffer_async.patch"

# 5. Validation FS + Anti-alias auto
- name: anti_alias_fs_validation
  description: >
    Dans optimized_fft_processor.py :
      • FS = float(os.getenv(...)), range valid 10–5000 Hz sinon ValueError
      • si FS < 1000 → appliquer filtre Butterworth 4ᵉ ordre 0.9*Nyquist
    Ajoute tests/test_anti_alias.py vérifiant sortie filtrée (attenuation
    > 20 dB @ 1.2×Nyquist).
  produce_patch: "__fixes__/patch_anti_alias.patch"

# 6. Bench « Cas D » 64 voies @ 100 Hz
- name: bench_case_d
  description: >
    Ajoute Cas D (64 voies, 100 Hz, 600 s) à bench_results_2025-07-15.json
    et modifie benchmark_performance.py pour l'exécuter.
    Critère : gain CPU optim / numpy ≤ 0.5, ΔHs < 5 %.
  produce_patch: "__fixes__/patch_bench_case_d.patch"

# 7. Cache Goda multi-géométries haute densité
- name: goda_cache_multi
  depends_on: bench_case_d
  description: >
    Dans optimized_goda_analyzer.py :
      • mémoisation (AᴴA, cholesky) key = (n_probes, fs, geom_hash)
      • benchmark interne (Cas D) doit afficher gain CPU ≥ 30 %
  produce_patch: "__fixes__/patch_goda_cache_multi.patch"

# 8. CI offline stricte + couverture 90 %
- name: ci_offline
  description: >
    Crée .github/workflows/offline.yml :
      • matrix {windows-latest, ubuntu-latest}
      • setup-python 3.11
      • pip install --no-index --find-links local_packages
      • pytest -q --cov=hrneowave --cov-fail-under=90
      • run benchmark_performance.py --fast
      • grep -RiE "(http|socket.create_connection)" src/ | wc -l == 0
  produce_patch: "__fixes__/patch_ci_offline.patch"

# 9. Gardien socket global
- name: offline_socket_guard
  description: >
    Ajoute module hrneowave/offline_guard.py :
      • monkey-patch socket.create_connection pour lever RuntimeError
        si CHNW_MODE == "offline".
    Importe-le dans hrneowave/__init__.py au tout début.
    Test pytest `tests/test_socket_guard.py` vérifie l'interdiction.
  produce_patch: "__fixes__/patch_offline_socket_guard.patch"

# 10. Documentation & changelog V0.3
- name: docs_changelog
  description: >
    Met à jour README.md + docs/ :
      • section OFFLINE strict,
      • instructions CLI,
      • intégration IOTech,
      • bench A–D.
    Ajoute CHANGELOG.md → version 0.3.0 avec liste complète des patchs.
  produce_patch: "__fixes__/patch_docs_changelog.patch"

# 11. Exécution finale offline
- name: final_launch
  depends_on:
    - purge_network_access
    - register_cli
    - hw_iotech_backend
    - anti_alias_fs_validation
    - offline_socket_guard
  run: >
    python -m hrneowave.launcher
      --config ${CHNW_GEOM}
      --offline
      --log-dir logs/