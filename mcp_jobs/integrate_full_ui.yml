# integrate_full_ui.yml - Int√©gration compl√®te GUI avec modules optimis√©s
# Fusionne ProcessingWorker/AcquisitionController avec OptimizedFFTProcessor/OptimizedGodaAnalyzer
# Remonte CircularBuffer, modernise GUI PyQtGraph, ajoute contr√¥les Start/Stop/Export

name: "Int√©gration UI Compl√®te CHNeoWave"
version: "1.0.0"
description: "Migration compl√®te vers modules optimis√©s avec GUI modernis√©e"

tasks:
  # Phase 1: Migration ProcessingWorker vers modules optimis√©s
  - name: "migrate_processing_worker"
    type: "code_refactor"
    source: "logciel hrneowave/processing_worker.py"
    target: "gui/processing/optimized_worker.py"
    actions:
      - replace_imports:
          old: |
            import numpy as np
            from scipy import signal
            from scipy.signal import welch
          new: |
            import numpy as np
            from src.hrneowave.core import OptimizedFFTProcessor, OptimizedGodaAnalyzer, CircularBuffer
            from src.hrneowave.core import BufferConfig, ProbeGeometry
      
      - replace_class_init:
          old: |
            def __init__(self, acquisition_controller, config: Dict[str, Any]):
                super().__init__()
                self.acquisition_controller = acquisition_controller
                self.config = config
                # Buffers circulaires pour chaque sonde
                self.data_buffers = {}
                self.buffer_size = config.get('buffer_size', 4096)
                self._init_buffers()
          new: |
            def __init__(self, acquisition_controller, config: Dict[str, Any]):
                super().__init__()
                self.acquisition_controller = acquisition_controller
                self.config = config
                
                # Configuration buffer optimis√©
                buffer_config = BufferConfig(
                    n_channels=config.get('n_channels', 4),
                    buffer_size=config.get('buffer_size', 4096),
                    sample_rate=config.get('sample_rate', 32.0),
                    dtype=np.float32
                )
                self.circular_buffer = CircularBuffer(buffer_config)
                
                # Processeur FFT optimis√©
                self.fft_processor = OptimizedFFTProcessor(
                    n_channels=buffer_config.n_channels,
                    fft_size=config.get('window_size', 1024),
                    sample_rate=buffer_config.sample_rate
                )
                
                # Analyseur Goda optimis√©
                probe_geometry = ProbeGeometry(
                    positions=config.get('probe_positions', [0, 1, 2, 3]),
                    water_depth=config.get('water_depth', 10.0)
                )
                self.goda_analyzer = OptimizedGodaAnalyzer(probe_geometry)
      
      - replace_method:
          name: "_compute_optimized_fft"
          old: |
            def _compute_optimized_fft(self, data: Dict[str, np.ndarray]) -> Dict[str, Any]:
                results = {}
                try:
                    for probe_id, signal_data in data.items():
                        # Pr√©traitement rapide
                        processed_signal = self._preprocess_signal(signal_data)
                        # FFT avec fen√™trage
                        window = signal.windows.hann(len(processed_signal))
                        windowed_signal = processed_signal * window
                        # Calcul FFT
                        fft_result = np.fft.fft(windowed_signal)
                        freqs = np.fft.fftfreq(len(windowed_signal), 1/self.sample_rate)
                        # Garder seulement les fr√©quences positives
                        positive_freqs = freqs[:len(freqs)//2]
                        positive_fft = fft_result[:len(fft_result)//2]
                        # Densit√© spectrale de puissance
                        psd = np.abs(positive_fft)**2 / (self.sample_rate * len(windowed_signal))
                        # Phase
                        phase = np.angle(positive_fft)
                        results[probe_id] = {
                            'freqs': positive_freqs,
                            'psd': psd,
                            'phase': phase,
                            'fft_complex': positive_fft
                        }
                except Exception as e:
                    self.processingError.emit(f"Erreur FFT: {str(e)}")
                return results
          new: |
            def _compute_optimized_fft(self, data: Dict[str, np.ndarray]) -> Dict[str, Any]:
                """Calcul FFT optimis√© utilisant OptimizedFFTProcessor"""
                try:
                    # Convertir les donn√©es au format attendu
                    channel_data = np.array([data[f'probe_{i}'] for i in range(len(data))])
                    
                    # Utiliser le processeur FFT optimis√© (gain +500%)
                    spectrum_result = self.fft_processor.compute_spectrum(channel_data)
                    
                    # Reformater pour compatibilit√©
                    results = {}
                    for i, probe_id in enumerate(data.keys()):
                        results[probe_id] = {
                            'freqs': spectrum_result['frequencies'],
                            'psd': spectrum_result['psd'][i],
                            'phase': spectrum_result['phase'][i],
                            'fft_complex': spectrum_result['complex_spectrum'][i]
                        }
                    
                    return results
                    
                except Exception as e:
                    self.processingError.emit(f"Erreur FFT optimis√©: {str(e)}")
                    return {}
      
      - replace_method:
          name: "_compute_optimized_goda"
          old: |
            def _compute_optimized_goda(self, data: Dict[str, np.ndarray], 
                                       spectra: Dict[str, Any]) -> Dict[str, Any]:
                try:
                    if not spectra or len(spectra) < 2:
                        return {}
                    # Prendre les deux premi√®res sondes pour l'analyse
                    probe_ids = list(spectra.keys())[:2]
                    probe1_id, probe2_id = probe_ids[0], probe_ids[1]
                    spec1 = spectra[probe1_id]
                    spec2 = spectra[probe2_id]
                    freqs = spec1['freqs']
                    # ... calculs manuels Goda ...
                except Exception as e:
                    self.processingError.emit(f"Erreur Goda: {str(e)}")
                    return {}
          new: |
            def _compute_optimized_goda(self, data: Dict[str, np.ndarray], 
                                       spectra: Dict[str, Any]) -> Dict[str, Any]:
                """Analyse Goda optimis√©e utilisant OptimizedGodaAnalyzer"""
                try:
                    if not spectra or len(spectra) < 2:
                        return {}
                    
                    # Pr√©parer les donn√©es pour l'analyseur optimis√©
                    wave_data = {
                        'frequencies': spectra[list(spectra.keys())[0]]['freqs'],
                        'complex_spectra': [spec['fft_complex'] for spec in spectra.values()],
                        'psd': [spec['psd'] for spec in spectra.values()]
                    }
                    
                    # Utiliser l'analyseur Goda optimis√© (gain +1000%)
                    wave_components = self.goda_analyzer.analyze_waves(wave_data)
                    
                    # Convertir au format attendu
                    return {
                        'Hs': wave_components.significant_height,
                        'Tp': wave_components.peak_period,
                        'Tm': wave_components.mean_period,
                        'Cr': wave_components.reflection_coefficient,
                        'direction': wave_components.mean_direction,
                        'm0_incident': wave_components.incident_energy,
                        'm0_reflected': wave_components.reflected_energy,
                        'peak_frequency': wave_components.peak_frequency
                    }
                    
                except Exception as e:
                    self.processingError.emit(f"Erreur Goda optimis√©: {str(e)}")
                    return {}
      
      - replace_method:
          name: "_read_new_data"
          old: |
            def _read_new_data(self):
                """Lit les nouvelles donn√©es du contr√¥leur d'acquisition"""
                if not self.acquisition_controller:
                    return
                try:
                    # Obtenir les donn√©es temps r√©el
                    time_data, channel_data = self.acquisition_controller.get_real_time_data()
                    if time_data is not None and channel_data is not None:
                        # Ajouter aux buffers
                        self._mutex.lock()
                        try:
                            for i, data in enumerate(channel_data):
                                if i < self.n_channels and len(data) > 0:
                                    # Ajouter les nouveaux √©chantillons
                                    for sample in data:
                                        self.data_buffers[f'probe_{i}'].append(sample)
                        finally:
                            self._mutex.unlock()
                except Exception as e:
                    self.processingError.emit(f"Erreur lecture donn√©es: {str(e)}")
          new: |
            def _read_new_data(self):
                """Lit les nouvelles donn√©es via CircularBuffer optimis√©"""
                if not self.acquisition_controller:
                    return
                try:
                    # Obtenir les donn√©es temps r√©el
                    time_data, channel_data = self.acquisition_controller.get_real_time_data()
                    
                    if time_data is not None and channel_data is not None:
                        # √âcriture thread-safe dans le buffer circulaire
                        data_array = np.array(channel_data, dtype=np.float32)
                        success = self.circular_buffer.write(data_array)
                        
                        if not success:
                            self.processingError.emit("Buffer overflow d√©tect√©")
                            
                except Exception as e:
                    self.processingError.emit(f"Erreur lecture donn√©es: {str(e)}")

  # Phase 2: Migration AcquisitionController
  - name: "migrate_acquisition_controller"
    type: "code_refactor"
    source: "logciel hrneowave/acquisition_controller.py"
    target: "gui/acquisition/optimized_controller.py"
    actions:
      - add_imports:
          imports: |
            from src.hrneowave.core import CircularBuffer, BufferConfig
            from src.hrneowave.hw import create_acquisition_controller
            from PyQt5.QtCore import QObject, pyqtSignal, QTimer
      
      - enhance_class:
          name: "AcquisitionController"
          add_signals: |
            # Signaux Qt thread-safe pour GUI
            dataReady = pyqtSignal(dict)  # {timestamp, spectra}
            statsUpdated = pyqtSignal(dict)  # {Hs, Tp, Cr, direction}
            bufferStatus = pyqtSignal(dict)  # {fill_ratio, overflow_count}
            errorOccurred = pyqtSignal(str)
          
          add_methods: |
            def get_buffer_stats(self) -> dict:
                """Retourne les statistiques du buffer circulaire"""
                if hasattr(self, 'processing_worker') and self.processing_worker:
                    return self.processing_worker.circular_buffer.get_stats()
                return {}
            
            def export_current_data(self, filepath: str) -> bool:
                """Exporte les donn√©es actuelles du buffer"""
                try:
                    if hasattr(self, 'processing_worker') and self.processing_worker:
                        available = self.processing_worker.circular_buffer.available_samples()
                        if available > 0:
                            data = self.processing_worker.circular_buffer.read(available)
                            np.save(filepath, data)
                            return True
                    return False
                except Exception as e:
                    self.errorOccurred.emit(f"Erreur export: {str(e)}")
                    return False

  # Phase 3: Modernisation GUI avec PyQtGraph
  - name: "modernize_gui"
    type: "code_refactor"
    source: "logciel hrneowave/acquisition.py"
    target: "gui/acquisition/modern_acquisition_window.py"
    actions:
      - replace_imports:
          old: |
            import matplotlib.pyplot as plt
            from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
            from matplotlib.figure import Figure
          new: |
            import pyqtgraph as pg
            from pyqtgraph import PlotWidget, GraphicsLayoutWidget
            import pyqtgraph.exporters
      
      - add_control_panel:
          widget_name: "ControlPanel"
          controls: |
            # Panneau de contr√¥le moderne
            self.control_layout = QHBoxLayout()
            
            # Boutons Start/Stop/Export
            self.start_btn = QPushButton("‚ñ∂ Start")
            self.start_btn.setStyleSheet("""
                QPushButton {
                    background-color: #4CAF50;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    font-size: 14px;
                    border-radius: 5px;
                }
                QPushButton:hover {
                    background-color: #45a049;
                }
            """)
            
            self.stop_btn = QPushButton("‚è∏ Stop")
            self.stop_btn.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    font-size: 14px;
                    border-radius: 5px;
                }
                QPushButton:hover {
                    background-color: #da190b;
                }
            """)
            
            self.export_btn = QPushButton("üíæ Export")
            self.export_btn.setStyleSheet("""
                QPushButton {
                    background-color: #2196F3;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    font-size: 14px;
                    border-radius: 5px;
                }
                QPushButton:hover {
                    background-color: #1976D2;
                }
            """)
            
            # Indicateurs de statut
            self.status_label = QLabel("Status: Arr√™t√©")
            self.buffer_label = QLabel("Buffer: 0%")
            self.latency_label = QLabel("Latence: 0ms")
            
            # Layout
            self.control_layout.addWidget(self.start_btn)
            self.control_layout.addWidget(self.stop_btn)
            self.control_layout.addWidget(self.export_btn)
            self.control_layout.addStretch()
            self.control_layout.addWidget(self.status_label)
            self.control_layout.addWidget(self.buffer_label)
            self.control_layout.addWidget(self.latency_label)
      
      - replace_plotting:
          old: |
            # Matplotlib plots
            self.figure = Figure()
            self.canvas = FigureCanvas(self.figure)
            self.ax1 = self.figure.add_subplot(211)
            self.ax2 = self.figure.add_subplot(212)
          new: |
            # PyQtGraph plots modernes
            self.graphics_layout = GraphicsLayoutWidget()
            
            # Graphique temps r√©el des signaux
            self.time_plot = self.graphics_layout.addPlot(
                title="Signaux Temps R√©el",
                labels={'left': 'Amplitude (m)', 'bottom': 'Temps (s)'}
            )
            self.time_plot.setLabel('left', 'Amplitude', units='m')
            self.time_plot.setLabel('bottom', 'Temps', units='s')
            self.time_plot.showGrid(x=True, y=True)
            
            # Graphique spectral
            self.graphics_layout.nextRow()
            self.spectrum_plot = self.graphics_layout.addPlot(
                title="Spectre de Puissance",
                labels={'left': 'PSD (m¬≤/Hz)', 'bottom': 'Fr√©quence (Hz)'}
            )
            self.spectrum_plot.setLogMode(y=True)
            self.spectrum_plot.showGrid(x=True, y=True)
            
            # Courbes pour chaque sonde
            self.time_curves = []
            self.spectrum_curves = []
            colors = ['r', 'g', 'b', 'y', 'c', 'm', 'w', 'k']
            
            for i in range(8):  # Max 8 sondes
                # Courbe temporelle
                curve_time = self.time_plot.plot(
                    pen=pg.mkPen(color=colors[i % len(colors)], width=2),
                    name=f'Sonde {i+1}'
                )
                self.time_curves.append(curve_time)
                
                # Courbe spectrale
                curve_spectrum = self.spectrum_plot.plot(
                    pen=pg.mkPen(color=colors[i % len(colors)], width=2),
                    name=f'Sonde {i+1}'
                )
                self.spectrum_curves.append(curve_spectrum)
      
      - add_update_methods:
          methods: |
            def update_real_time_plots(self, data_dict: dict):
                """Mise √† jour des graphiques temps r√©el avec PyQtGraph"""
                try:
                    if 'spectra' in data_dict:
                        spectra = data_dict['spectra']
                        
                        for i, (probe_id, spec_data) in enumerate(spectra.items()):
                            if i < len(self.spectrum_curves):
                                freqs = spec_data['freqs']
                                psd = spec_data['psd']
                                
                                # Mise √† jour spectrale (plus rapide que matplotlib)
                                self.spectrum_curves[i].setData(freqs, psd)
                    
                    if 'time_data' in data_dict:
                        time_data = data_dict['time_data']
                        
                        for i, (probe_id, signal_data) in enumerate(time_data.items()):
                            if i < len(self.time_curves):
                                # Afficher seulement les derni√®res secondes
                                n_display = min(1000, len(signal_data))
                                time_axis = np.arange(n_display) / self.sample_rate
                                
                                self.time_curves[i].setData(time_axis, signal_data[-n_display:])
                                
                except Exception as e:
                    print(f"Erreur mise √† jour graphiques: {e}")
            
            def update_status_indicators(self, stats_dict: dict):
                """Mise √† jour des indicateurs de statut"""
                try:
                    if 'buffer_stats' in stats_dict:
                        buffer_stats = stats_dict['buffer_stats']
                        fill_ratio = buffer_stats.get('fill_ratio', 0) * 100
                        self.buffer_label.setText(f"Buffer: {fill_ratio:.1f}%")
                    
                    if 'latency_ms' in stats_dict:
                        latency = stats_dict['latency_ms']
                        self.latency_label.setText(f"Latence: {latency:.1f}ms")
                        
                        # Alerte si latence > 200ms
                        if latency > 200:
                            self.latency_label.setStyleSheet("color: red; font-weight: bold;")
                        else:
                            self.latency_label.setStyleSheet("color: green;")
                            
                except Exception as e:
                    print(f"Erreur mise √† jour statut: {e}")
            
            def export_data(self):
                """Export des donn√©es avec dialogue de fichier"""
                try:
                    from PyQt5.QtWidgets import QFileDialog
                    
                    filepath, _ = QFileDialog.getSaveFileName(
                        self,
                        "Exporter les donn√©es",
                        f"acquisition_{time.strftime('%Y%m%d_%H%M%S')}.npz",
                        "Fichiers NumPy (*.npz);;Tous les fichiers (*)"
                    )
                    
                    if filepath and hasattr(self, 'acquisition_controller'):
                        success = self.acquisition_controller.export_current_data(filepath)
                        
                        if success:
                            QMessageBox.information(self, "Export", f"Donn√©es export√©es: {filepath}")
                        else:
                            QMessageBox.warning(self, "Export", "√âchec de l'export")
                            
                except Exception as e:
                    QMessageBox.critical(self, "Erreur", f"Erreur export: {str(e)}")

  # Phase 4: Tests d'int√©gration
  - name: "integration_tests"
    type: "test_suite"
    target: "tests/integration/test_optimized_integration.py"
    tests:
      - name: "test_fft_performance"
        description: "V√©rifier gain performance FFT ‚â• 500%"
        code: |
          def test_fft_performance():
              import time
              import numpy as np
              from src.hrneowave.core import OptimizedFFTProcessor
              
              # Donn√©es test
              n_channels, n_samples = 4, 1024
              test_data = np.random.randn(n_channels, n_samples).astype(np.float32)
              
              # Test FFT optimis√©
              fft_processor = OptimizedFFTProcessor(n_channels, n_samples, 32.0)
              
              start_time = time.time()
              for _ in range(100):  # 100 it√©rations
                  result = fft_processor.compute_spectrum(test_data)
              optimized_time = time.time() - start_time
              
              # Test FFT numpy (baseline)
              start_time = time.time()
              for _ in range(100):
                  for channel in test_data:
                      np.fft.fft(channel)
              numpy_time = time.time() - start_time
              
              # V√©rifier gain ‚â• 500%
              speedup = numpy_time / optimized_time
              assert speedup >= 5.0, f"Gain FFT insuffisant: {speedup:.1f}x < 5.0x"
      
      - name: "test_goda_performance"
        description: "V√©rifier gain performance Goda ‚â• 1000%"
        code: |
          def test_goda_performance():
              import time
              from src.hrneowave.core import OptimizedGodaAnalyzer, ProbeGeometry
              
              # Configuration test
              probe_geometry = ProbeGeometry(
                  positions=[(0, 0), (1, 0), (2, 0), (3, 0)],
                  water_depth=10.0
              )
              goda_analyzer = OptimizedGodaAnalyzer(probe_geometry)
              
              # Donn√©es test
              freqs = np.linspace(0.05, 2.0, 512)
              complex_spectra = [np.random.complex64(512) for _ in range(4)]
              wave_data = {
                  'frequencies': freqs,
                  'complex_spectra': complex_spectra,
                  'psd': [np.abs(spec)**2 for spec in complex_spectra]
              }
              
              # Test performance
              start_time = time.time()
              for _ in range(50):  # 50 it√©rations
                  result = goda_analyzer.analyze_waves(wave_data)
              optimized_time = time.time() - start_time
              
              # V√©rifier latence ‚â§ 5ms par analyse
              avg_latency_ms = (optimized_time / 50) * 1000
              assert avg_latency_ms <= 5.0, f"Latence Goda trop √©lev√©e: {avg_latency_ms:.1f}ms > 5ms"
      
      - name: "test_gui_responsiveness"
        description: "V√©rifier r√©activit√© GUI ‚â§ 16ms"
        code: |
          def test_gui_responsiveness(qtbot):
              import time
              from gui.acquisition.modern_acquisition_window import AcquisitionSetupWindow
              
              # Cr√©er fen√™tre test
              window = AcquisitionSetupWindow()
              qtbot.addWidget(window)
              
              # Simuler donn√©es temps r√©el
              test_data = {
                  'spectra': {
                      'probe_0': {
                          'freqs': np.linspace(0, 16, 512),
                          'psd': np.random.rand(512),
                          'phase': np.random.rand(512)
                      }
                  }
              }
              
              # Mesurer temps de mise √† jour
              start_time = time.time()
              for _ in range(60):  # 60 FPS
                  window.update_real_time_plots(test_data)
                  qtbot.wait(1)  # 1ms entre updates
              total_time = time.time() - start_time
              
              # V√©rifier ‚â§ 16ms par frame (60 FPS)
              avg_frame_time_ms = (total_time / 60) * 1000
              assert avg_frame_time_ms <= 16.0, f"GUI trop lente: {avg_frame_time_ms:.1f}ms > 16ms"

  # Phase 5: Validation finale
  - name: "final_validation"
    type: "validation"
    checks:
      - imports_check:
          description: "V√©rifier imports modules optimis√©s"
          files:
            - "gui/processing/optimized_worker.py"
            - "gui/acquisition/optimized_controller.py"
          required_imports:
            - "src.hrneowave.core.OptimizedFFTProcessor"
            - "src.hrneowave.core.OptimizedGodaAnalyzer"
            - "src.hrneowave.core.CircularBuffer"
      
      - performance_check:
          description: "V√©rifier m√©triques de performance"
          requirements:
            - "FFT speedup ‚â• 5x"
            - "Goda speedup ‚â• 10x"
            - "GUI latency ‚â§ 16ms"
            - "Processing latency ‚â§ 5ms"
      
      - coverage_check:
          description: "V√©rifier couverture tests ‚â• 88%"
          command: "pytest --cov=src --cov=gui --cov-report=term-missing"
          min_coverage: 88

expected_results:
  - "ProcessingWorker migr√© vers modules optimis√©s"
  - "AcquisitionController utilise CircularBuffer thread-safe"
  - "GUI modernis√©e avec PyQtGraph (gain performance graphique)"
  - "Contr√¥les Start/Stop/Export fonctionnels"
  - "Latence traitement ‚â§ 5ms"
  - "R√©activit√© GUI ‚â§ 16ms"
  - "Couverture tests ‚â• 88%"
  - "Aucune r√©gression fonctionnelle"