#!/usr/bin/env python3
"""
Test smoke - Certificat PDF de calibration
Génère une calibration 3 points et crée un PDF < 150 kB
"""

import pytest
import sys
import os
import tempfile
import json
from pathlib import Path
from PyQt5.QtWidgets import QApplication

# Ajout du chemin source
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from hrneowave.utils.calib_pdf import CalibrationPDFGenerator
from hrneowave.utils.hash_tools import hash_string

class TestCalibPDF:
    """Tests de génération de certificats PDF de calibration"""
    
    @pytest.fixture(scope="class")
    def qapp(self):
        """Fixture pour l'application Qt"""
        if not QApplication.instance():
            app = QApplication(sys.argv)
        else:
            app = QApplication.instance()
        yield app
    
    @pytest.fixture
    def temp_dir(self):
        """Répertoire temporaire pour les tests"""
        with tempfile.TemporaryDirectory() as tmpdir:
            yield Path(tmpdir)
    
    @pytest.fixture
    def sample_calibration_data(self):
        """Données de calibration d'exemple avec 3 points"""
        return {
            'sensor_count': 2,
            'sensors': [
                {
                    'id': 1,
                    'name': 'Capteur 1',
                    'gain': 1.0234,
                    'offset': -0.0156,
                    'r_squared': 0.9987,
                    'points': [
                        {'reference': 0.0, 'measured': -0.0156, 'error': -0.0156},
                        {'reference': 5.0, 'measured': 5.1014, 'error': 0.1014},
                        {'reference': 10.0, 'measured': 10.2184, 'error': 0.2184}
                    ]
                },
                {
                    'id': 2,
                    'name': 'Capteur 2',
                    'gain': 0.9876,
                    'offset': 0.0234,
                    'r_squared': 0.9992,
                    'points': [
                        {'reference': 0.0, 'measured': 0.0234, 'error': 0.0234},
                        {'reference': 5.0, 'measured': 4.9614, 'error': -0.0386},
                        {'reference': 10.0, 'measured': 9.9004, 'error': -0.0996}
                    ]
                }
            ]
        }
    
    def test_pdf_generator_basic(self, temp_dir, sample_calibration_data):
        """Test basique de génération PDF"""
        output_file = temp_dir / 'test_basic.pdf'
        
        try:
            # Génération du PDF
            generator = CalibrationPDFGenerator()
            generator.generate_certificate(sample_calibration_data, str(output_file))
            
            # Vérifications
            assert output_file.exists(), "Fichier PDF non créé"
            
            file_size = output_file.stat().st_size
            file_size_kb = file_size / 1024
            
            print(f"Taille PDF: {file_size_kb:.1f} kB")
            
            assert file_size > 1000, "Fichier PDF trop petit (< 1 kB)"
            assert file_size_kb < 150, f"Fichier PDF trop gros: {file_size_kb:.1f} kB > 150 kB"
            
            # Vérification que c'est bien un PDF
            with open(output_file, 'rb') as f:
                header = f.read(4)
                assert header == b'%PDF', "Le fichier n'est pas un PDF valide"
            
            print(f"✓ PDF généré avec succès: {output_file.name} ({file_size_kb:.1f} kB)")
            
        except Exception as e:
            pytest.fail(f"Erreur génération PDF basique: {str(e)}")
    
    def test_pdf_content_verification(self, temp_dir, sample_calibration_data):
        """Test de vérification du contenu PDF"""
        output_file = temp_dir / 'test_content.pdf'
        
        try:
            # Génération du PDF
            generator = CalibrationPDFGenerator()
            generator.generate_certificate(sample_calibration_data, str(output_file))
            
            # Extraction du texte PDF avec PyPDF2
            try:
                import PyPDF2
                with open(output_file, 'rb') as f:
                    pdf_reader = PyPDF2.PdfReader(f)
                    pdf_content = ""
                    for page in pdf_reader.pages:
                        pdf_content += page.extract_text()
            except ImportError:
                # Fallback vers lecture brute si PyPDF2 n'est pas disponible
                with open(output_file, 'rb') as f:
                    pdf_content = f.read().decode('latin-1', errors='ignore')
            
            # Vérifications de contenu
            assert 'CHNeoWave' in pdf_content, "Titre CHNeoWave manquant"
            assert 'CERTIFICAT' in pdf_content, "Mot 'CERTIFICAT' manquant"
            assert 'CALIBRATION' in pdf_content, "Mot 'CALIBRATION' manquant"
            
            # Vérification des données de capteurs
            for sensor in sample_calibration_data['sensors']:
                sensor_id = str(sensor['id'])
                # Le PDF utilise "Canal" dans le tableau, pas les noms complets
                assert sensor_id in pdf_content, f"ID du capteur '{sensor_id}' manquant"
                
                # Vérification des valeurs numériques (format approximatif)
                gain_str = f"{sensor['gain']:.6f}"  # Le PDF utilise 6 décimales
                r_squared_str = f"{sensor['r_squared']:.6f}"
                
                # Vérifier la présence des valeurs de gain et R²
                assert gain_str in pdf_content, f"Valeur de gain {gain_str} manquante pour capteur {sensor_id}"
                assert r_squared_str in pdf_content, f"Valeur R² {r_squared_str} manquante pour capteur {sensor_id}"
            
            print("✓ Contenu PDF vérifié")
            
        except Exception as e:
            pytest.fail(f"Erreur vérification contenu PDF: {str(e)}")
    
    def test_pdf_with_high_quality_calibration(self, temp_dir):
        """Test avec calibration haute qualité (R² ≥ 0.998)"""
        # Données de calibration haute qualité
        high_quality_data = {
            'sensor_count': 1,
            'sensors': [
                {
                    'id': 1,
                    'name': 'Capteur Haute Précision',
                    'gain': 1.0000,
                    'offset': 0.0000,
                    'r_squared': 0.9999,
                    'points': [
                        {'reference': 0.0, 'measured': 0.0000, 'error': 0.0000},
                        {'reference': 5.0, 'measured': 5.0001, 'error': 0.0001},
                        {'reference': 10.0, 'measured': 9.9999, 'error': -0.0001}
                    ]
                }
            ]
        }
        
        output_file = temp_dir / 'high_quality.pdf'
        
        try:
            # Génération du PDF
            generator = CalibrationPDFGenerator()
            generator.generate_certificate(high_quality_data, str(output_file))
            
            # Vérifications
            assert output_file.exists(), "PDF haute qualité non créé"
            
            file_size_kb = output_file.stat().st_size / 1024
            assert file_size_kb < 150, f"PDF haute qualité trop gros: {file_size_kb:.1f} kB"
            
            print(f"✓ PDF haute qualité généré: {file_size_kb:.1f} kB")
            
        except Exception as e:
            pytest.fail(f"Erreur PDF haute qualité: {str(e)}")
    
    def test_pdf_with_multiple_sensors(self, temp_dir):
        """Test avec plusieurs capteurs (jusqu'à 8)"""
        # Génération de données pour 8 capteurs
        import random
        random.seed(42)  # Pour la reproductibilité
        
        multi_sensor_data = {
            'sensor_count': 8,
            'sensors': []
        }
        
        for i in range(8):
            # Génération de données de calibration réalistes
            gain = 1.0 + random.uniform(-0.05, 0.05)
            offset = random.uniform(-0.1, 0.1)
            r_squared = random.uniform(0.995, 0.9999)
            
            points = []
            for ref_val in [0.0, 5.0, 10.0]:
                measured = gain * ref_val + offset + random.uniform(-0.01, 0.01)
                error = measured - ref_val
                points.append({
                    'reference': ref_val,
                    'measured': measured,
                    'error': error
                })
            
            sensor = {
                'id': i + 1,
                'name': f'Capteur {i + 1}',
                'gain': gain,
                'offset': offset,
                'r_squared': r_squared,
                'points': points
            }
            
            multi_sensor_data['sensors'].append(sensor)
        
        output_file = temp_dir / 'multi_sensors.pdf'
        
        try:
            # Génération du PDF
            generator = CalibrationPDFGenerator()
            generator.generate_certificate(multi_sensor_data, str(output_file))
            
            # Vérifications
            assert output_file.exists(), "PDF multi-capteurs non créé"
            
            file_size_kb = output_file.stat().st_size / 1024
            print(f"Taille PDF 8 capteurs: {file_size_kb:.1f} kB")
            
            # Pour 8 capteurs, on peut accepter un fichier un peu plus gros
            assert file_size_kb < 200, f"PDF multi-capteurs trop gros: {file_size_kb:.1f} kB"
            
            print(f"✓ PDF 8 capteurs généré: {file_size_kb:.1f} kB")
            
        except Exception as e:
            pytest.fail(f"Erreur PDF multi-capteurs: {str(e)}")
    
    def test_pdf_signature_verification(self, temp_dir, sample_calibration_data):
        """Test de vérification de la signature SHA-256"""
        output_file = temp_dir / 'test_signature.pdf'
        
        try:
            # Génération du PDF
            generator = CalibrationPDFGenerator()
            generator.generate_certificate(sample_calibration_data, str(output_file))
            
            # Calcul du hash des données de calibration
            calib_json = json.dumps(sample_calibration_data, sort_keys=True)
            expected_hash = hash_string(calib_json)
            
            # Extraction du texte PDF avec PyPDF2
            try:
                import PyPDF2
                with open(output_file, 'rb') as f:
                    pdf_reader = PyPDF2.PdfReader(f)
                    pdf_content = ""
                    for page in pdf_reader.pages:
                        pdf_content += page.extract_text()
            except ImportError:
                # Fallback vers lecture brute si PyPDF2 n'est pas disponible
                with open(output_file, 'rb') as f:
                    pdf_content = f.read().decode('latin-1', errors='ignore')
            
            # Le hash devrait être présent dans le PDF
            hash_short = expected_hash[:16]  # Premiers 16 caractères
            assert hash_short in pdf_content, f"Hash SHA-256 manquant dans le PDF: {hash_short}"
            
            print(f"✓ Signature SHA-256 vérifiée: {expected_hash[:16]}...")
            
        except Exception as e:
            pytest.fail(f"Erreur vérification signature: {str(e)}")
    
    def test_pdf_error_handling(self, temp_dir):
        """Test de gestion d'erreurs"""
        try:
            generator = CalibrationPDFGenerator()
            
            # Test avec données invalides - doit lever une ValueError
            invalid_data = {'invalid': 'data'}
            
            with pytest.raises(ValueError):
                generator.generate_certificate(invalid_data, str(temp_dir / 'invalid.pdf'))
            
            # Test avec chemin invalide - doit retourner False
            valid_data = {
                'sensor_count': 1,
                'sensors': [{
                    'id': 1,
                    'name': 'Test',
                    'gain': 1.0,
                    'offset': 0.0,
                    'r_squared': 0.999,
                    'points': []
                }]
            }
            
            invalid_path = '/invalid/path/test.pdf'
            result = generator.generate_certificate(valid_data, invalid_path)
            assert result == False, "La génération avec un chemin invalide devrait retourner False"
            
            print("✓ Gestion d'erreurs fonctionnelle")
            
        except Exception as e:
            pytest.fail(f"Erreur test gestion d'erreurs: {str(e)}")

if __name__ == '__main__':
    # Exécution directe pour debug
    pytest.main([__file__, '-v'])